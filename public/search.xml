<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java中new一个对象的过程</title>
      <link href="/2021/09/20/JAVA-new%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E8%BF%87%E7%A8%8B/"/>
      <url>/2021/09/20/JAVA-new%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>java 在 new 一个对象前，会先查看对象所属类有没有被加载到 jvm 的方法区内（1.8 之后的元空间，下文不再提示）。如果没有，会加载和初始化该类，之后进行创建对象的工作。所以第一次使用某类时，会进行类<code>加载</code>，类<code>连接</code>（验证、准备、解析），<code>初始化</code>类，最后创建对象。</p><span id="more"></span><h2 id="一、类加载过程"><a href="#一、类加载过程" class="headerlink" title="一、类加载过程"></a>一、类加载过程</h2><p>由类加载器负责根据一个类的全限定名来读取此类的二进制字节流到 jvm 内部，并存储在运行时内存区的方法区，然后将其转换为一个与目标类型对应的 java.lang.Class 对象实例</p><p>java 使用<code>双亲委派模型</code>进行类加载，用来维护类的唯一性（jvm 在判定两个类是否相同时，不仅要判断两个类名是否相同，而且要判断是否由同一个类加载器实例加载的。只有两者同时满足的情况下，jvm 才认为这两个类是相同的）。</p><blockquote><p>双亲委派模型的工作过程是：当该类第一次使用时，该类的类加载器（ClassLoader）收到类加载请求，首先将这个请求交给父类加载器完成，每一个层次的类加载器都是如此，所以所有加载请求最后都是交给顶层的启动类加载器，只有当父类加载器无法完成这个加载请求时，子加载器会去尝试加载……总结：自底向上传递类加载请求，自上向下尝试加载类。</p></blockquote><p><img src="/images/classloader.png" alt="image-20200831225137263"></p><p>双亲委派模型的好处是：能够确保一个类的全局唯一性，如果没有此模型，我们可以随时使用自定义的类替代 java 核心类，这样会有很大的安全隐患。</p><h2 id="二、类的连接过程"><a href="#二、类的连接过程" class="headerlink" title="二、类的连接过程"></a>二、类的连接过程</h2><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>格式验证：验证是否符合 class 文件规范</p><p>语义验证：检查一个被标记为 final 的类型是否包含子类；检查一个类中的 final 方法是否被子类进行重写；确保父类和子类之间没有不兼容的一些方法声明（比如方法签名相同，但方法的返回值不同）</p><p>操作验证：在操作数栈中的数据必须进行正确的操作，对常量池中的各种符号引用执行验证（通常在解析阶段执行，检查是否可以通过符号引用中描述的全限定名定位到指定类型上，以及类成员信息的访问修饰符是否允许访问等）</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>为类中的所有<code>静态变量</code>分配内存空间，并为其设置一个初始值。而被 final 修饰的 static 变量（常量）会直接赋值。</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>将常量池中的符号引用转为直接引用（得到类或者字段、方法在内存中的指针或者偏移量，以便直接调用该方法），这个可以在初始化之后再执行。解析需要静态绑定的内容。所有不会被重写的方法和域都会被静态绑定</p><blockquote><p>符号引用：由字符串表示（jvm 运行时无法直接使用，因为没有关联内存空间），例如：“java/io/PrintStream.println:(Ljava/lang/String;)V”。里面有类的信息，方法名，方法参数等信息。。</p></blockquote><blockquote><p>直接引用：解析成直接引用就是将符号引用（字符串）解析成 jvm 在运行时直接使用的“数据”，例如虚方法表的下标，通过偏移量虚拟机可以直接在该类的内存区域中找到方法字节码的起始位置。</p></blockquote><h2 id="三、类的初始化"><a href="#三、类的初始化" class="headerlink" title="三、类的初始化"></a>三、类的初始化</h2><ul><li><p>为静态变量赋值</p></li><li><p>执行 static 代码块</p></li></ul><p><strong>注意</strong>：static 代码块只有 jvm 能够调用，如果是多线程需要同时初始化一个类，仅仅只能允许其中一个线程对其执行初始化操作，其余线程必须等待，只有在活动线程执行完对类的初始化操作之后，才会通知正在等待的其他线程。</p><p>因为子类存在对父类的依赖，所以类的加载顺序是先加载父类后加载子类，初始化也一样。不过父类初始化时，子类静态变量的值是默认值。</p><p>最终方法区会存储当前类类信息，包括类的静态变量、类初始化代码（定义静态变量时的赋值语句 和 静态初始化代码块、实例变量定义、实例初始化代码（定义实例变量时的赋值语句实例代码块和构造方法 ）和实例方法，还有父类的类信息引用。</p><h2 id="四、创建对象"><a href="#四、创建对象" class="headerlink" title="四、创建对象"></a>四、创建对象</h2><ol><li><p>在堆内存分配对象需要的内存空间</p><p>分配的内存空间包括本类和父类的所有实例变量，但不包括任何静态变量（1.8 之后静态变量和常量池都在堆中创建）</p></li><li><p>对所有实例变量赋默认值</p><p>将方法区内对实例变量的定义拷贝一份到堆区，然后赋默认值（_默认值是由 jvm 自动赋的，所以在单例模式 DCL 时要加 volatile_）</p></li><li><p>执行实例初始化代码</p><p>初始化顺序是先初始化父类再初始化子类，初始化时先执行实例代码块然后是构造方法</p></li><li><p>如果有类似于<code>Child c = new Child()</code>形式的引用，在栈区定义<code>Child</code>类型引用变量 <code>c</code>，然后将堆区对象的地址赋值给它</p><p><strong>需要注意</strong>：每个字类对象持有父类对象的引用，可通过 super 调用父类对象，但外部不可访问。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WSL2 安装nodejs</title>
      <link href="/1970/01/01/WSL2-%E5%AE%89%E8%A3%85nodejs/"/>
      <url>/1970/01/01/WSL2-%E5%AE%89%E8%A3%85nodejs/</url>
      
        <content type="html"><![CDATA[<p>在使用<code>hexo</code>创建博客的时候用到<code>nodejs</code>和<code>npm</code>，博主第一次接触 js 的管理工具，所以从头安装，在 win10 上使用的时候，除了配置环境变量之外，在使用<code>npm</code>时需要用管理员运行 pwsh，所以就转到 WSL 上，在搜索教程时，看到 WSL1 在安装 nodejs 时可能会有一些问题，如果你是 WSL1 并遇到问题，可以尝试升级到 WSL2。</p><blockquote><p>博主使用的是 ubuntu18.04LTS 版本的 WSL2</p></blockquote><span id="more"></span><h2 id="安装-nodejs"><a href="#安装-nodejs" class="headerlink" title="安装 nodejs"></a>安装 nodejs</h2><p>安装之前看网上说使用<code>nvm</code>管理 node，博主安装之后，仍有一些错误（可能与博主对前端的东西接触到过少），所以采用 ubuntu 存储库安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install nodejs npm</span><br></pre></td></tr></table></figure><p>_注意_：安装的是 nodejs，ubuntu 存储库中有软件包与 node 冲突。</p><p>查看安装结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nodejs --version</span><br><span class="line"><span class="meta">#</span><span class="bash"> v14.17.6</span></span><br><span class="line">npm --version</span><br><span class="line"><span class="meta">#</span><span class="bash"> 6.14.15</span></span><br></pre></td></tr></table></figure><p>如果版本低于博主版本，建议先升级：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install n -g</span><br><span class="line">sudo n stable</span><br></pre></td></tr></table></figure><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>升级完成之后可以执行一下命令，验证一下是否有错误提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo -g</span><br></pre></td></tr></table></figure><p>如果报权限问题，按以下顺序进行设置，成功为止：</p><ol><li><p>设置 npm 的权限：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set unsafe-perm=true</span><br></pre></td></tr></table></figure></li><li><p>如果开启 vscode 的 Remote WSL，需要关闭 WSL，WSL2 可以在 pwsh 中执行<code>wsl --shutdown</code></p></li><li><p>修改 prefix 目录，更改 npm 的 global 仓库地址：</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set prefix=&quot;$&#123;HOME&#125;/npm-global&quot;</span><br></pre></td></tr></table></figure><p>博主基本设置到这里就可以使用，但每个人的错误可能不一样，需要大家自行搜索解决，最后一步解决办法请参考：<a href="https://im.shellj.com/2020/05/wsl-npm-install-permission-denied-error.html">wsl npm install EACCES: permission denied 错误解决方法</a></p><h2 id="npm-加速"><a href="#npm-加速" class="headerlink" title="npm 加速"></a>npm 加速</h2><p>npm 在使用时，可能会出现速度过慢，博主在 WSL 上使用速度奇慢，但是在 ali 云上就是另一种体验，可能这就是金钱的力量。</p><p>1.运行以下命令设置淘宝镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>之后正常使用 npm 即可，在搜索时发现有安装 cnpm 的办法，博主没有采用，大家可以自行尝试。</p><p>2.由于 WSL2 与 WSL1 不同，无法通过直接监听<code>本地</code>端口配置加速，需要先查看 win10 机器的 ip，具体流程如下（参考<a href="https://zhuanlan.zhihu.com/p/153124468">为 WSL2 一键设置代理</a>）：</p><ul><li>首先在 ss 等软件上开启允许本地 LAN 连接（端口号视使用的软件而定）</li></ul><img src="/images/WSL2/lan.png" style="zoom:50%;" /><ul><li>然后配置脚本将 win10 的 ip 配置到 WSL 的监听中，在 WSL 个人目录下创建<code>.proxyrc</code>。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">host_ip=$(cat /etc/resolv.conf |grep <span class="string">&quot;nameserver&quot;</span> |cut -f 2 -d <span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="built_in">export</span> ALL_PROXY=<span class="string">&quot;http://<span class="variable">$host_ip</span>:7890&quot;</span></span><br></pre></td></tr></table></figure><ul><li>使用时只需要 <code>source .proxyrc</code> 就可以生效脚本即可。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> .proxyrc</span><br></pre></td></tr></table></figure><ul><li>win10 的 ip 不变的情况下，也可以将<code>export ALL_PROXY=&quot;http://$host_ip:7890&quot;</code>配置为环境变量（个人目录的<code>.bashrc</code>），直接在 bash 启动时就监听加速端口（各位自行尝试）。</li></ul></br><blockquote><p>博客写的不多，如有错误请各位见谅，可以的话请联系我更正，谢谢！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 日常挖坑 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WSL </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
