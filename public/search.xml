<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java中new一个对象的过程</title>
      <link href="/2021/09/20/JAVA-new%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E8%BF%87%E7%A8%8B/"/>
      <url>/2021/09/20/JAVA-new%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>java 在 new 一个对象前，会先查看对象所属类有没有被加载到 jvm 的方法区内（1.8 之后的元空间，下文不再提示）。如果没有，会加载和初始化该类，之后进行创建对象的工作。所以第一次使用某类时，会进行类<strong>加载</strong>，类<strong>连接</strong>（验证、准备、解析），<strong>初始化</strong>类，最后创建对象。</p><span id="more"></span><h2 id="一、类加载过程"><a href="#一、类加载过程" class="headerlink" title="一、类加载过程"></a>一、类加载过程</h2><p>由类加载器负责根据一个类的全限定名来读取此类的二进制字节流到 JVM 内部，并存储在运行时内存区的方法区，然后将其转换为一个与目标类型对应的 java.lang.Class 对象实例</p><p>java 使用<strong>双亲委派模型</strong>进行类加载，用来维护类的唯一性（jvm 在判定两个类是否相同时，不仅要判断两个类名是否相同，而且要判断是否由同一个类加载器实例加载的。只有两者同时满足的情况下，jvm 才认为这两个类是相同的）。</p><blockquote><p>双亲委派模型的工作过程是：当该类第一次使用时，该类的类加载器（ClassLoader）收到类加载请求，首先将这个请求交给父类加载器完成，每一个层次的类加载器都是如此，所以所有加载请求最后都是交给顶层的启动类加载器，只有当父类加载器无法完成这个加载请求时，子加载器会去尝试加载……总结：自底向上传递类加载请求，自上向下尝试加载类。</p></blockquote><p><img src="/images/classloader.png" alt="image-20200831225137263"></p><p>双亲委派模型的好处是：能够确保一个类的全局唯一性，如果没有此模型，我们可以随时使用自定义的类替代 java 核心类，这样会有很大的安全隐患。</p><h2 id="二、类的连接过程"><a href="#二、类的连接过程" class="headerlink" title="二、类的连接过程"></a>二、类的连接过程</h2><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>格式验证：验证是否符合 class 文件规范</p><p>语义验证：检查一个被标记为 final 的类型是否包含子类；检查一个类中的 final 方法是否被子类进行重写；确保父类和子类之间没有不兼容的一些方法声明（比如方法签名相同，但方法的返回值不同）</p><p>操作验证：在操作数栈中的数据必须进行正确的操作，对常量池中的各种符号引用执行验证（通常在解析阶段执行，检查是否可以通过符号引用中描述的全限定名定位到指定类型上，以及类成员信息的访问修饰符是否允许访问等）</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>为类中的所有<strong>静态变量</strong>分配内存空间，并为其设置一个初始值。而被 final 修饰的 static 变量（常量）会直接赋值。</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>将常量池中的符号引用转为直接引用（得到类或者字段、方法在内存中的指针或者偏移量，以便直接调用该方法），这个可以在初始化之后再执行。解析需要静态绑定的内容。 所有不会被重写的方法和域都会被静态绑定</p><blockquote><p>符号引用：由字符串表示（jvm 运行时无法直接使用，因为没有关联内存空间），例如：“java/io/PrintStream.println:(Ljava/lang/String;)V”。里面有类的信息，方法名，方法参数等信息。。</p></blockquote><blockquote><p>直接引用：解析成直接引用就是将符号引用（字符串）解析成 jvm 在运行时直接使用的“数据”，例如虚方法表的下标，通过偏移量虚拟机可以直接在该类的内存区域中找到方法字节码的起始位置。</p></blockquote><h2 id="三、类的初始化"><a href="#三、类的初始化" class="headerlink" title="三、类的初始化"></a>三、类的初始化</h2><ul><li><p>为静态变量赋值</p></li><li><p>执行 static 代码块</p></li></ul><p><strong>注意</strong>：static 代码块只有 jvm 能够调用，如果是多线程需要同时初始化一个类，仅仅只能允许其中一个线程对其执行初始化操作，其余线程必须等待，只有在活动线程执行完对类的初始化操作之后，才会通知正在等待的其他线程。</p><p>因为子类存在对父类的依赖，所以类的加载顺序是先加载父类后加载子类，初始化也一样。不过，父类初始化时，子类静态变量的值也有有的，是默认值。</p><p>最终，方法区会存储当前类类信息，包括类的静态变量 、类初始化代码 （定义静态变量时的赋值语句 和 静态初始化代码块）、实例变量定义 、实例初始化代码 （定义实例变量时的赋值语句实例代码块 和构造方法 ）和实例方法 ，还有父类的类信息引用。</p><h2 id="四、创建对象"><a href="#四、创建对象" class="headerlink" title="四、创建对象"></a>四、创建对象</h2><ol><li><p>在堆内存分配对象需要的内存空间</p><p>分配的内存空间包括本类和父类的所有实例变量，但不包括任何静态变量（1.8 之后静态变量和常量池都在堆中创建）</p></li><li><p>对所有实例变量赋默认值</p><p>将方法区内对实例变量的定义拷贝一份到堆区，然后赋默认值（_默认值是由 jvm 自动赋的，所以在 DCL 时要加 volatile_）</p></li><li><p>执行实例初始化代码</p><p>初始化顺序是先初始化父类再初始化子类，初始化时先执行实例代码块然后是构造方法</p></li><li><p>如果有类似于<strong>Child c = new Child()<strong>形式的引用，在栈区定义</strong>Child</strong>类型引用变量 c，然后将堆区对象的地址赋值给它</p><p><strong>需要注意</strong>：每个字类对象持有父类对象的引用，可通过 super 调用父类对象，但外部不可访问。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
